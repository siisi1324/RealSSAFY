# 선택정렬
# 버블정렬과 비교하면서 이홰하기
# 주어진 자료들 중 가장 작은 값의 원소부터 차례대로 선택하여 위치를 교환하는 방식

# 정렬과정
# 1) 주어진 리스트 중에서 최소값을 찾는다.
# 2) 그 값을 리스트의 맨 앞에 위치한 값과 교환한다.
# 3) 맨 처음 위치를 제외한 나머지 리스트를 대상으로 위의 과정을 반복한다. 


def selection_sort(a, N):
    for i in range(N-1): #기준위치(최소값을 찾는 구간의 시작 인덱스스)
        min_idx = i  # 최솟값 인덱스 초기화, 구간의 맨 앞 원소를 최소로 가정
        for j in range(i+1, N): #실제 최솟값인지 비교하는 위치
            if a[min_idx] > a[j]:
                min_idx = j
        # if i!=min_idx:  i번의 비교연산과 추가의 교환연산이 발생한다. 굳이 필요치 않다. 
        a[i], a[min_idx] = a[min_idx], a[i]
        # 파이선이라 가능한 튜플 바꾸기


arr = [10, 25, 64, 22, 11]

selection_sort(arr, len(arr))
print(arr)

print('=====================================================')

# 셀렉션 알고리즘
# 저장되어 있는 자료로부터 k번째로 큰 혹은 작은 원소를 찾는 방법을 셀렉션 알고리즘이라고 한다. 
# 최소값, 최대값 혹은 중간값을 찾는 알고리즘을 의미하기도 한다. 

# 1) 정렬 알고리즘을 이용하여 자료 정렬하기
# 2) 원하는 순서에 있는 원소 가져오기

def selection_sort(a, N):
    for i in range(N-1): #기준위치(최소값을 찾는 구간의 시작 인덱스스)
        min_idx = i  # 최솟값 인덱스 초기화, 구간의 맨 앞 원소를 최소로 가정
        for j in range(i+1, N): #실제 최솟값인지 비교하는 위치
            if a[min_idx] > a[j]:
                min_idx = j
        # if i!=min_idx:  i번의 비교연산과 추가의 교환연산이 발생한다. 굳이 필요치 않다. 
        a[i], a[min_idx] = a[min_idx], a[i]

print('=====================================================')

# swea 달팽이숫자(list2의 최종연습문제)