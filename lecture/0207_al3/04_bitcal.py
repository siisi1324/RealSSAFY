# & : 비트 단위로 AND 연산을 한다. 
# | : 비트 단위로 OR 연산을 한다.
# << : 피연산자의 비트 열을 왼쪽으로 이동시킨다. 
# 1 << n : 2**n 즉, 원소가 n개일 경우의 모든 부분집합의 수를 의미한다. 

# >> : 피연산자의 비트 열을 오른쪽으로 이동시킨다. 
# i & (1<<j) : i의 j번째 비트가 1인지 아닌지를 검사한다. 

arr = [3, 6, 7, 1, 5, 4]

n = len(arr) # 원소의 개수수

for i in range(1<<n):  # 1<<n : 부분 집합의 개수수
    for j in range(n): # 원소의 수많큼 비트를 비교함함
        if i & (1<<j): # i의 j번 비트가 1인경우
            print(arr[j], end="") # j번 원소 출력
    print()
print()


print('=====================================================')

# <연습문제>
# 부분집합 합 문제 구현하기
# 10개의 정수를 입력받아 부분집합의 합이 0이 되는 것이 존재하는지를 계산하는 함수를 작성해보자.

arr = [-7, -5, 2, 3, 8, -2, 4, 6, 9]
# 전설의 10중 포문