# <그리디 알고리즘 = 탐욕 알고리즘>
# 그리디 알고리즘(Greedy Algorithm)은 매 순간 최적이라고 생각되는 선택을 하여 전체 문제의 최적해를 구하는 방법이다.
# 각 단계에서의 선택이 이후의 결과에 영향을 미치지 않으며, 지역적으로 최선의 선택이 결국 전역적으로도 최선이 되는 문제에 적용할 수 있다.
# 대표적인 예로 거스름돈 문제, 크루스칼 알고리즘(최소 신장 트리), 그리고 활동 선택 문제 등이 있다.

# 1) 해 선택 : 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 부분해집합(Solution Set)에 추가한다.
# ex. 거스름돈 줄이기 : 단위가 가장 큰 동전을 먼저 고른다. 

# 2) 실행 가능성 검사 : 새로운 부분해 집합이 실행 가능한지를 확인한다. 곧, 문제의 제약 조건을 위반하지 않는지를 검사한다.
# ex. 거스름돈이 손님께 드려야할 액수를 초과하면 마지막 동전을 뺴고 1)로 돌아가서 한 단계 작은 단위의 동전을 추가한다. 

# 3) 해 검사 : 새로운 부분해 집합이 문제의 해가 되는지를 확인한다. 아직 전체 문제의 해가 완성되지 않았다면 1)의 해 선택부터 다시 시작한다.
# ex. 거스름돈이 모자라면 다시 1)로 돌아가서 거스름돈에 추가할 동전을 고른다. 


# 구현 예)

num = int(input()) #Baby Gin 확인할 6자리 수 
c = [0] * 12  # 6자리 수로부터 각 자리 수를 추출하여 개수를 누적할 리스트
# c[10], c[11]은 항상 0, run 확인을 위한 여분

for i in range(6): # 단순 반복 6회회
    c[num % 10] += 1 # num%10 1의 자리 알아내기기
    num //= 10 # num의 1의 자리 제거
print(c) # [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0]


i = 0
tri = run = 0
while i < 10:
    if c[i] >= 3: #triplete 조사 후 삭제 
        c[i] -= 3
        tri +- 1
        continue #triplete이 2개인 경우를 생각하기 위해서(같은 작업을 두 번 반복)
    if c[i] >= 1 and c[i+1] >= 1 and c[i+2] >= 1 : # run 조사 후 데이터 삭제
        c[i] -= 1
        c[i+1] -= 1
        c[i+2] -= 1
        run += 1
        continue
    i += 1

if run + tri == 2 :
    print('Baby Gin')
else:
    print("Lose")


print("----------------------------------------------------------------")