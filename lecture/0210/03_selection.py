# 선택정렬
# 버블정렬과 비교하면서 이홰하기
# 사실 둘 다 효율성이 똥이다.. 
# 주어진 자료들 중 가장 작은 값의 원소부터 차례대로 선택하여 위치를 교환하는 방식
# just for 정렬

# 정렬과정
# 1) 주어진 리스트 중에서 최소값을 찾는다.
# 2) 그 값을 리스트의 맨 앞에 위치한 값과 교환한다.
# 3) 맨 처음 위치를 제외한 나머지 리스트를 대상으로 위의 과정을 반복한다. 


def selection_sort(a, N):
    for i in range(N-1): #기준위치(최소값을 찾는 구간의 시작 인덱스스)
        min_idx = i  # 최솟값 인덱스 초기화, 구간의 맨 앞 원소를 최소로 가정
        for j in range(i+1, N): #실제 최솟값인지 비교하는 위치
            if a[min_idx] > a[j]:
                min_idx = j
        # if i!=min_idx:  i번의 비교연산과 추가의 교환연산이 발생한다. 굳이 필요치 않다. 
        a[i], a[min_idx] = a[min_idx], a[i]
        # 파이선이라 가능한 튜플 바꾸기


arr = [10, 25, 64, 22, 11]

selection_sort(arr, len(arr))
print(arr)

print('=====================================================')

# 셀렉션 알고리즘
# 저장되어 있는 자료로부터 k번째로 큰 혹은 작은 원소를 찾는 방법을 셀렉션 알고리즘이라고 한다. 
# 최소값, 최대값 혹은 중간값을 찾는 알고리즘을 의미하기도 한다. 
# 정렬을 하지 않고 필요한 원소만 찾는 것이 목적.

# 정렬과정
# 1) 정렬 알고리즘을 이용하여 자료 정렬하기
# 2) 원하는 순서에 있는 원소 가져오기

# k번째로 작은 원소를 찾는 알고리즘
arr = [6, 5, 1, 2, 4, 8, 2, 7]  # 정렬되지 않은 리스트

def select(arr, k):
    """
    배열에서 k번째 작은 원소를 찾는 셀렉션 알고리즘.
    - 선택 정렬과 유사하지만, k번째 원소까지만 정렬하여 반환.
    - O(n^2) 복잡도를 가지지만, 전체 정렬보다 효율적.
    
    :param arr: 정렬되지 않은 배열
    :param k: k번째 작은 원소를 찾기 위한 값
    :return: k번째 작은 원소
    """
    for i in range(0, k):  # k번째까지 반복
        min_index = i  # 현재 최소값의 위치를 저장
        for j in range(i+1, len(arr)):  # i 이후의 요소들을 탐색하여 최소값 찾기
            if arr[min_index] > arr[j]:  # 더 작은 값이 발견되면
                min_index = j  # 최소값 인덱스 업데이트
        arr[i], arr[min_index] = arr[min_index], arr[i]  # 최소값을 i번째 위치로 교환
    
    return arr[k-1]  # k번째 작은 값 반환 (인덱스는 0부터 시작하므로 k-1 사용)

# 배열의 가장 큰 값 찾기 (전체 정렬 없이 가장 큰 값만 찾음)
print(select(arr.copy(), 3))  # 3번째로 큰 값 # 2

