# 깊이 우선 탐색(Depth First Search, DFS)
# 너비 우선 탐색(Breadth First Search, BFS)
# 얘는 가로순(행)으로 (밑으로 간다)

# <DFS>
# 시작 정점의 한 방향으로 갈 수 있는 경로가 있는 곳까지 깊이 탐색해 가다가 더 이상 갈 곳이 없게 되면, 
# 가장 마지막에 만났던 갈림길 간선이 있는 정점으로 되돌아와서 다른 방향의 정점으로 탐색을 계속 반복하여 
# 결국 모든 정점을 방문하는 순회 방법

# 가장 마지막에 만났던 갈림길의 정점으로 되돌아가서 
# 다시 깊이 우선 탐색을 반복해야 하므로 후입선출(LIFO: Last-In-First-Out) 구조의 스택 사용

# 1. 시작 정점 v를 결정하여 방문한다.
# 2. 정점 v에 인접한 정점 중에서
#     a. 방문하지 않은 정점 w가 있으면, 정점v를 스택에 push하고 정점 w를 방문한다. 그리고 w를 v로 하여 다시 2. 를 반복한다
#     b. 방문하지 않은 정점이 없으면, 탐색의 방향을 바꾸기 위해 스택을 pop하여 받은 가장 마지막 방문 정점을 v로 하여 다시 2.를 반복한다
# 3. 스택이 공백이 될 때까지 2.를 반복한다.

# 출발점은 항상 1이 아니어도 된다. 

# 경호오빠 노션이나, 수업자료로 보기

# 걍 여러가지 중에 왼쪽부터 가고, 이미 갔으면 다음 걸 가면 된다. 

# [연습문제]
# 입력조건을 잘 봐라

'''
7 8
간선정보(EDGE) : 1 2 1 3 2 4 2 5 4 6 5 6 6 7 3 7
노드(VERTEX)
간선(1:1로 이어지는 관계)의 개수 : E(EDGE) : 8
정점의 개수 : V(VERTEX) 

'''
def dfs(v, N):            # v: 시작 정점, N: 마지막 정점 번호
    visited = [0] * (N + 1)     # 방문 여부를 저장하는 리스트 (0: 방문X, 1: 방문O)
    stack = []                  # 스택 (백트래킹용)

    while True:
        if visited[v] == 0:  # 처음 방문하는 정점이면
            visited[v] = 1
            print(v)  # 방문한 정점 출력

        for w in adj_list[v]:   # 현재 정점 v에 인접한 정점들을 확인
            if visited[w] == 0:  # 아직 방문하지 않은 정점이 있으면
                stack.append(v)  # 현재 정점을 스택에 저장 (백트래킹을 위해)
                v = w            # 다음 정점으로 이동
                break             # 이동했으므로 for문 종료 후 다음 루프 실행
        else:                    # 더 이상 방문할 정점이 없으면
            if stack:             # 스택에 저장된 정점이 있다면 (백트래킹)
                v = stack.pop()  # 이전 정점으로 돌아감
            else:                # 스택이 비어 있으면 탐색 종료
                break

V, E = map(int, input().split())  # V: 정점 개수, E: 간선 개수
graph = list(map(int, input().split()))  # 간선 정보 입력
adj_list = [[] for _ in range(V+1)]  # 인접 리스트 생성 (0번 인덱스는 사용 X)

for i in range(E):
    v, w = graph[i*2], graph[i*2+1]  # 간선 정보 분리 (v ↔ w)
    adj_list[v].append(w)  # v에서 w로 가는 간선 추가
    adj_list[w].append(v)  # w에서 v로 가는 간선 추가 (무방향 그래프)

dfs(1, V)  
