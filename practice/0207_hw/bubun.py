A = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]  # 1부터 12까지의 정수를 포함하는 리스트

T = int(input())  # 테스트 케이스 개수를 입력받음

for tc in range(1, T+1):  # 테스트 케이스 개수만큼 반복
    N, K = map(int, input().split())  # N: 부분집합의 크기, K: 부분집합 원소 합의 목표값
    result = 0  # 조건을 만족하는 부분집합의 개수를 저장할 변수

    # 1 << len(A)는 2^12 (4096), 즉 리스트 A의 모든 부분집합을 확인하는 과정
    for i in range(1 << len(A)):  
        subset = []  # 현재 선택된 원소를 저장할 리스트
        # 불필요한 리스트라고 한다. 

        # 비트마스크를 활용하여 부분집합 생성
        for j in range(len(A)):  # A의 원소(12개)에 대해 비트를 확인
            if i & (1 << j):  # i의 j번째 비트가 1이면 선택된 원소
                subset.append(A[j])  # 부분집합에 추가

        # 부분집합의 원소 개수가 N개인지 확인
        if len(subset) == N:
            sum_v = 0  # 부분집합의 합을 저장할 변수
            for num in subset:  # 부분집합의 모든 원소를 더함
                sum_v += num
            
            # 부분집합의 합이 K와 같다면 결과 카운트 증가
            if sum_v == K:
                result += 1

    print(f'#{tc} {result}')  # 테스트 케이스 번호와 결과 출력

# 연습필요..!!
# 필수까지는 아니고,,(비트연산)
# 백트래킹도 안된다고 한다. 
# 이해는 하시되, 집착은 마시라..